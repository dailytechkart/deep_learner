---
title: 'Chat Application (Messenger) System Design'
difficulty: 'Hard'
timeEstimate: '60 minutes'
category: 'System Design'
---

# Chat Application (Messenger) System Design

## Problem Statement

Design a real-time chat application similar to Facebook Messenger that can handle millions of users, support various message types (text, images, videos), and provide features like message delivery status, typing indicators, and group chats.

## High-Level Design (HLD)

### System Requirements

- Support millions of concurrent users
- Real-time message delivery
- Message persistence
- Support for different message types (text, images, videos)
- Message delivery status
- Typing indicators
- Group chat functionality
- Message search
- User presence status
- Message encryption

### Components

1. **Client Applications**

   - Web application
   - Mobile applications (iOS, Android)
   - Desktop applications

2. **Load Balancer**

   - Distributes incoming requests across multiple servers
   - Handles SSL termination
   - Implements health checks

3. **WebSocket Servers**

   - Maintains persistent connections with clients
   - Handles real-time message delivery
   - Manages user presence
   - Implements typing indicators

4. **Application Servers**

   - Handles HTTP requests
   - Manages user authentication
   - Processes message storage
   - Handles file uploads
   - Implements business logic

5. **Message Queue**

   - Decouples message processing from delivery
   - Handles message persistence
   - Manages offline message delivery
   - Implements retry mechanisms

6. **Database Layer**

   - User data (PostgreSQL)
   - Message data (MongoDB)
   - Media storage (Object Storage)
   - Cache layer (Redis)

7. **Search Service**
   - Indexes messages for quick search
   - Implements full-text search
   - Handles search queries

### Data Flow

1. **Message Sending**

   ```
   Client -> Load Balancer -> WebSocket Server -> Message Queue -> Application Server -> Database
   ```

2. **Message Receiving**

   ```
   Database -> Application Server -> Message Queue -> WebSocket Server -> Client
   ```

3. **File Upload**
   ```
   Client -> Load Balancer -> Application Server -> Object Storage -> Database
   ```

## Low-Level Design (LLD)

### Database Schema

#### Users Table

```sql
CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen TIMESTAMP,
    status VARCHAR(20)
);
```

#### Messages Table

```sql
CREATE TABLE messages (
    message_id UUID PRIMARY KEY,
    sender_id UUID REFERENCES users(user_id),
    receiver_id UUID REFERENCES users(user_id),
    content TEXT,
    message_type VARCHAR(20),
    media_url VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    delivered_at TIMESTAMP,
    read_at TIMESTAMP,
    is_deleted BOOLEAN DEFAULT FALSE
);
```

#### Group Chats Table

```sql
CREATE TABLE group_chats (
    group_id UUID PRIMARY KEY,
    name VARCHAR(100),
    created_by UUID REFERENCES users(user_id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Group Members Table

```sql
CREATE TABLE group_members (
    group_id UUID REFERENCES group_chats(group_id),
    user_id UUID REFERENCES users(user_id),
    role VARCHAR(20),
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (group_id, user_id)
);
```

### API Endpoints

#### Authentication

```typescript
POST / api / auth / register;
POST / api / auth / login;
POST / api / auth / logout;
GET / api / auth / me;
```

#### Messages

```typescript
POST /api/messages
GET /api/messages/:conversationId
PUT /api/messages/:messageId
DELETE /api/messages/:messageId
```

#### Groups

```typescript
POST /api/groups
GET /api/groups
GET /api/groups/:groupId
PUT /api/groups/:groupId
DELETE /api/groups/:groupId
```

#### Users

```typescript
GET /api/users
GET /api/users/:userId
PUT /api/users/:userId
GET /api/users/search
```

### WebSocket Events

```typescript
// Client to Server
interface ClientEvents {
  'message:send': (data: MessageData) => void;
  'typing:start': (data: { conversationId: string }) => void;
  'typing:stop': (data: { conversationId: string }) => void;
  'presence:update': (data: { status: UserStatus }) => void;
}

// Server to Client
interface ServerEvents {
  'message:new': (data: MessageData) => void;
  'message:delivered': (data: { messageId: string }) => void;
  'message:read': (data: { messageId: string }) => void;
  'typing:start': (data: { userId: string; conversationId: string }) => void;
  'typing:stop': (data: { userId: string; conversationId: string }) => void;
  'presence:update': (data: { userId: string; status: UserStatus }) => void;
}
```

### Security Considerations

1. **Message Encryption**

   - End-to-end encryption for messages
   - TLS for all communications
   - Secure WebSocket connections

2. **Authentication**

   - JWT-based authentication
   - Refresh token rotation
   - Rate limiting
   - IP-based blocking

3. **Data Protection**
   - Data encryption at rest
   - Regular security audits
   - GDPR compliance
   - Data retention policies

### Scalability Considerations

1. **Horizontal Scaling**

   - Stateless application servers
   - Database sharding
   - Read replicas
   - CDN for media delivery

2. **Caching Strategy**

   - Redis for session data
   - CDN for static assets
   - In-memory caching for frequent queries
   - Cache invalidation policies

3. **Performance Optimization**
   - Message pagination
   - Lazy loading of media
   - Connection pooling
   - Query optimization

### Monitoring and Logging

1. **Metrics**

   - Response times
   - Error rates
   - User engagement
   - System resource usage

2. **Logging**

   - Application logs
   - Error logs
   - Access logs
   - Audit logs

3. **Alerts**
   - System health
   - Error thresholds
   - Resource utilization
   - Security incidents

## Conclusion

This system design provides a scalable and maintainable architecture for a chat application. The design considers real-time communication, data persistence, security, and scalability. The implementation can be further optimized based on specific requirements and constraints.

## Additional Considerations

1. **Future Scalability**

   - Support for voice and video calls
   - Message reactions and replies
   - Message editing
   - Message forwarding

2. **Performance Optimization**

   - Message compression
   - Image optimization
   - Connection pooling
   - Database indexing

3. **User Experience**
   - Offline support
   - Message synchronization
   - Push notifications
   - Message search
